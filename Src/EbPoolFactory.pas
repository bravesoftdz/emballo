{   Copyright 2010 - Magno Machado Paulo (magnomp@gmail.com)

    This file is part of Emballo.

    Emballo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Emballo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar.  If not, see <http://www.gnu.org/licenses/>. }

unit EbPoolFactory;

interface

uses
  EbAbstractWrapperFactory, Ebfactory, Classes, Generics.Collections;

type
  TStub = array[0..MAXINT - 1] of Byte;
  PStub = ^TStub;

  THackedRelease = function(Obj: TObject): Integer of object;

  { This class is responsible for patching the _Release stub
    generated by the Delphi compiler so that it will call a dynamically generated
    method instead of the original _Release method. This dynamically generated
    method will just call a THackedRelease method. I couldn't call the
    THackedRelease directly from the stub because it's declaration differs from
    the original _Release method declaration.

    This class is also responsible for undoing the patch operation }
  TStubPatch = class
  private
    FStub: PStub;
    FGeneraedStub: PStub;
    procedure SetJumpAddress(JumpDestination: Pointer);
    procedure GenerateStub(HackedRelease: THackedRelease);
  public
    { Instantiates a TStubPatch, but doesn't do the patch yet.
      StubAddress is a pointer to the stub to be patched }
    constructor Create(StubAddress: Pointer);

    { Do the patch. HackedRelease is the method that must be called }
    procedure Patch(HackedRelease: THackedRelease);

    { Undo the patch. OriginalRelease is a pointer to the original _Release
      method }
    procedure Unpatch(OriginalRelease: Pointer);
  end;

  TPoolFactory = class(TAbstractWrapperFactory)
  private
    FPatchedInterface: Boolean;
    FOriginalRelease: Pointer;
    FMax: Integer;
    FPool: IInterfaceList;
    FUnavailable: TList;
    FStubPatches: Generics.Collections.TList<TStubPatch>;
    function HackedRelease(Obj: TObject): Integer;
    procedure PatchInterfaceIdNeeded(Intf: Pointer);
  protected
    function GetInstance: IInterface; override;
  public
    constructor Create(const ActualFactory: IFactory; Max: Integer);
    destructor Destroy; override;
  end;

implementation

uses
  Windows, SysUtils;

type
  TArrayOfPointer = array[0..(MAXINT div SizeOf(Pointer)) - 1] of Pointer;
  PArrayOfPointer = ^TArrayOfPointer;
  PPArrayOfPointer = ^PArrayOfPointer;

{ TPoolFactory }

constructor TPoolFactory.Create(const ActualFactory: IFactory; Max: Integer);
begin
  inherited Create(ActualFactory);
  FMax := Max;
  FPool := TInterfaceList.Create;
  FUnavailable := TList.Create; { It MUST be a list of raw pointers because we
    need fine controu about ref. couting. This is to avoid automatic ref.
    couting when we're inside our HackedRelease method, as this would cause an
    infinite loop. We do the ref. counting manually by calling the original
    release method when appropriated }
end;

destructor TPoolFactory.Destroy;
var
  StubPatch: TStubPatch;
begin
  FUnavailable.Free;
  if FPatchedInterface then
  begin
    for StubPatch in FStubPatches do
    begin
      StubPatch.Unpatch(FOriginalRelease);
      StubPatch.Free;
    end;
  end;
  inherited;
end;

function TPoolFactory.GetInstance: IInterface;
begin
  if FPool.Count > 0 then
  begin
    Result := FPool[0];
    FPool.Delete(0);
  end
  else
    Result := FActualFactory.GetInstance;

  FUnavailable.Add(Pointer(Result));
  Result._AddRef;

  PatchInterfaceIdNeeded(Pointer(Result));
end;

function TPoolFactory.HackedRelease(Obj: TObject): Integer;
var
  OriginalRelease: function: Integer of object; stdcall;
  Intf: Pointer;
  Intf2: IInterface;
begin
  TMethod(OriginalRelease).Code := FOriginalRelease;
  TMethod(OriginalRelease).Data := Obj;
  Result := OriginalRelease;

  if Result = 1 then
  begin
    { When ref. count reaches one, it means that the only remaining
      reference is the one stored on FUnavailable. In other words: The object
      not in use anymore, and can now return to the pool or be freed }

    Supports(Obj, IInterface, Intf);
    { The Supports() above addref'd the object, so we undo this now }
    OriginalRelease;

    if FPool.Count < FMax then
    begin
      { If there's free space on the pool, then return the object to the pool }
      Supports(Obj, IInterface, Intf2);
      FPool.Add(Intf2);
      Intf2 := Nil;
      FUnavailable.Remove(Obj);
      { As we removed from the pool, now decrease the ref. count }
      OriginalRelease;
    end
    else
    begin
      { The pool is full. So, we'll really free the object. For that, we call
        the original Release method once again }
      OriginalRelease;
    end;
  end;
end;

procedure TPoolFactory.PatchInterfaceIdNeeded(Intf: Pointer);
const
  RELEASE_INDEX = 2;
var
  M: PArrayOfPointer;
  Stub: PStub;
  JmpOffset: Integer;
  StubPatch: TStubPatch;
begin
  if FPatchedInterface then
    Exit;

  FPatchedInterface := True;

  M := PPArrayOfPointer(Intf)^;
  Stub := PStub(M^[RELEASE_INDEX]);
  Move(Stub^[6], JmpOffset, SizeOf(Integer));
  FOriginalRelease := Pointer(Integer(Stub) + 10 + JmpOffset);
  FStubPatches := Generics.Collections.TList<TStubPatch>.Create;

  FStubPatches.Add(TStubPatch.Create(Stub));

  for StubPatch in FStubPatches do
    StubPatch.Patch(HackedRelease);
end;

{ TStubPatch }

constructor TStubPatch.Create(StubAddress: Pointer);
begin
  FStub := PStub(StubAddress);
end;

procedure TStubPatch.GenerateStub(HackedRelease: THackedRelease);
var
  Counter: Integer;

  procedure Put(const Bytes; Size: Integer); overload;
  begin
    Move(Bytes, FGeneraedStub^[Counter], Size);
    Inc(Counter, Size);
  end;

  procedure Put(B: Byte); overload;
  begin
    Put(B, 1);
  end;

  procedure Put(I: Integer); overload;
  begin
    Put(I, SizeOf(Integer));
  end;
var
  M: TMethod;
begin
  M := TMethod(HackedRelease);

  { Generated stub is going to be like:
    function GeneratedStub(Self: TObject): Integer; stdcall;
    begin
      Result := HackedRelease(Self);
    end;}

  GetMem(FGeneraedStub, 17);
  Counter := 0;

  { mov edx, [esp + $04]
    Takes the first parameter (the "Self") and prepares to pass it as the
    second parameter to the TPoolFactory.HackedRelease method }
  Put($8B); Put($54); Put($24); Put($04);

  { mov eax, <pointer to the TPoolFactory instance>
    We'll move the address of this TPoolFactory into eax in order to pass it to
    our HackedRelease method }
  Put($B8); Put(Integer(M.Data));

  { call <offset the HackedRelease code address>
    Now it's OK to call the HackedRelease method }
  Put($E8); Put(Integer(M.Code) - Integer(FGeneraedStub) - Counter - 4);

  { ret $0004
    Return to the caller }
  Put($C2); Put($04); Put($00);
end;

procedure TStubPatch.Patch(HackedRelease: THackedRelease);
begin
  GenerateStub(HackedRelease);
  SetJumpAddress(FGeneraedStub);
end;

procedure TStubPatch.SetJumpAddress(JumpDestination: Pointer);
var
  JumpOffset: Integer;
  OldProtect: Cardinal;
  JumpOffsetPointer: Pointer;
begin
  JumpOffsetPointer := @(FStub^[6]);

  JumpOffset := Integer(JumpDestination) - (Integer(FStub) + 10);

  if not VirtualProtect(JumpOffsetPointer, SizeOf(Integer), PAGE_READWRITE, OldProtect) then
    RaiseLastOSError;

  Move(JumpOffset, JumpOffsetPointer^, SizeOf(Integer));

  if not VirtualProtect(JumpOffsetPointer, SizeOf(Integer), OldProtect, OldProtect) then
    RaiseLastOSError;
end;

procedure TStubPatch.Unpatch(OriginalRelease: Pointer);
begin
  SetJumpAddress(OriginalRelease);
  FreeMem(FGeneraedStub);
end;

end.
